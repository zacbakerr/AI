def alphabeta(board,token, lowerBnd, upperBnd):
    if token == 'x':
        eTkn = 'o'
    else:
        eTkn = 'x'
    token_moves = runGetMoves(board,token)
    etkn_moves = runGetMoves(board,eTkn)
    if len(token_moves)==0:
        if len(etkn_moves) == 0:
            return [board.count(token)-board.count(eTkn)]
        bestSoFar=[lowerBnd-1]
        key = (board,eTkn,-upperBnd,-lowerBnd)
        if key not in CACHE:
            CACHE[key] = alphabeta(board,eTkn,-upperBnd,-lowerBnd)
        ab = CACHE[key]
        #ab = alphabeta(board,eTkn,-upperBnd,-lowerBnd)
        if -ab[0] > bestSoFar[0]:
            bestSoFar = [-ab[0]] + ab[1:] + [-1]
        return bestSoFar
    bestSoFar=[lowerBnd-1]
    for mv in token_moves:
        newBoard = makeMove(board, token, mv, token_moves)
        key = (newBoard,eTkn,-upperBnd,-lowerBnd)
        if key not in CACHE:
            CACHE[key] = alphabeta(newBoard,eTkn,-upperBnd,-lowerBnd)
        ab = CACHE[key]
        #ab = alphabeta(newBoard,eTkn,-upperBnd,-lowerBnd)
        score = -ab[0]
        if score < lowerBnd: continue
        if score > upperBnd:
            return [score]
        bestSoFar = [-ab[0]] + ab[1:] + [mv]
        lowerBnd = score+1
    return bestSoFar